(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{622:function(e,t,l){"use strict";l.r(t);var _=l(6),i=Object(_.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"_1-虚拟dom中key的作用"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-虚拟dom中key的作用"}},[e._v("#")]),e._v(" 1. 虚拟DOM中key的作用：")]),e._v(" "),l("ul",[l("li",[e._v("简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用")]),e._v(" "),l("li",[e._v("详细的说：当状态中数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】，随后react进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：\n"),l("ul",[l("li",[l("p",[e._v("旧虚拟DOM找到了新虚拟DOM相同的key：")]),e._v(" "),l("ul",[l("li",[l("ol",[l("li",[e._v("若虚拟DOM中内容没有变化，直接使用之前的真是DOM")])])]),e._v(" "),l("li",[l("ol",{attrs:{start:"2"}},[l("li",[e._v("若虚拟DOM中内容发生变化，则生成新的真实DOM，随后替换页面之前真实的DOM")])])])])]),e._v(" "),l("li",[l("p",[e._v("旧虚拟DOM未找到与新虚拟DOM相同的key")]),e._v(" "),l("ul",[l("li",[e._v("根据新数据创建新的真实DOM，随后渲染到页面")])])])])])]),e._v(" "),l("h2",{attrs:{id:"_2-为什么遍历列表时-key最好不要用index"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么遍历列表时-key最好不要用index"}},[e._v("#")]),e._v(" 2. 为什么遍历列表时，key最好不要用index")]),e._v(" "),l("ul",[l("li",[e._v("若数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新===》界面效果没有问题，但效率低")]),e._v(" "),l("li",[e._v("如果结构中还包含输入类的DOM：会产生错误DOM更新===》界面有问题。")]),e._v(" "),l("li",[e._v("注意，如果不存在数据逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表展示，使用index作为Key是没有问题的")])])])}),[],!1,null,null,null);t.default=i.exports}}]);